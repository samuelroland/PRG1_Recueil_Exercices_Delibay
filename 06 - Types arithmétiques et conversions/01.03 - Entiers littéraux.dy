Exo: Littéraux constants
TODO: okay de refactoriser la solution (pas l'instruction) en mode "long int v2 = 1;" -> "long int 1" puisque "v2 =" n'apporte rien ? adapter la consigne en conséquence
TODO: transformer en autocorrectible en même temps
TODO: a verifier

Pour chacune des lignes de code suivantes, indiquez 
- si elle compile
- si oui
  - quel est le type de la variable
  - ce que la ligne affiche; 

On suppose que le compilateur utilise le modèle de donnée LLP64, i.e, avec `int` et `long` codés sur 32 bits et `long long` sur 64.
**NB** 
Pour simplifier les réponses, au lieu de: "long int v2 = 1;", veuillez écrire: "long int 1"
En cas d'erreur de compilation, écrire: `nocompile`
Subexo: 
~~~
  auto v1 = 12u;        cout << v1 << endl;
~~~
Solution: 
unsigned int 12

Subexo: 
~~~
  auto v2 = 1L;         cout << v2 << endl;
~~~
Solution: 
long int 1    

Subexo: 
~~~  
  auto v3 = 100'000'000'000; cout << v3 << endl;
~~~
Solution: 
long long 100'000'000'000
Explanation:
ou long en LP64, voir int dans un modèle de donnée plus
exotique. Dans tous les cas, le plus petit type entier capable 
de stoquer la valeur 100000000000

Subexo: 
~~~  
  auto v4 = 0x33;      cout << v4 << endl;
~~~
Solution:                           
int 51
Explanation:
33 en hexadécimal : 3 * 16 + 3 * 1

Subexo: 
~~~  
  auto v5 = 0xefg;     cout << v5 << endl;
~~~
Solution: 
nocompile
Explanation:
`g` n'est pas un chiffre hexadécimal

Subexo: 
~~~  
  auto v6 = 0xef;      cout << v6 << endl;
~~~
Solution: 
int 239
Explanation:
ef en hexadécimal : 14 * 16 + 15

Subexo: 
~~~  
  auto v7 = 0xEF;      cout << v7 << endl;
~~~
Solution: 
int 239
Explanation:
EF en hexadécimal : 14 * 16 + 15

Subexo: 
~~~  
  auto v8 = 08;        cout << v8 << endl;
~~~
Solution: 
nocompile
Explanation:
`8` n'est pas un chiffre octal

Subexo: 
~~~  
  auto v9 = 027;       cout << v9 << endl;
~~~
Solution: 
int 23
Explanation:
027 en octal : 2*8+7 

Subexo: 
~~~  
  auto v10 = 0xffull;       cout << v10 << endl;
~~~
Solution: 
unsigned long long 255
Explanation:
ff en hexadécimal : 15*16+15

Subexo: 
~~~  
  auto v11 = 0xffffffff;       cout << v11 << endl;
~~~
Solution: 
unsigned int 4294967295 
Explanation:
2^32-1, valeur qui n'est pas représentable en signed int

Subexo: 
~~~  
  auto v12 = 0x7fffffff;       cout << v12 << endl;
~~~
Solution: 
int 2147483647
Explanation:
2^31-1, le plus grand int représentable

Subexo: 
~~~
   auto v13 = 0b010101; cout << v13;
~~~
Solution: 
int 21
Explanation:
010101 en binaire : 0*32 + 1*16 + 0*8 + 1*4 + 0*2 + 1*1

Subexo: 
~~~
   auto v14 = 0b101ul; cout << v14;
~~~
Solution: 
unsigned long 5
Explanation:
101 en binaire : 1*4 + 0*2 + 1*1
