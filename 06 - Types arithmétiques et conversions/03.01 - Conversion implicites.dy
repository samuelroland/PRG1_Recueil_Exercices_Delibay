Exo: [open] Conversions implicites
TODO: transformer en format solution en <nombre de conversions> <valeur final> pour rendre aucorrectible ??

Soient les déclarations suivantes :
~~~cpp
char c = 'A';
int n = 7;
int a = -2;
unsigned b = 1;
long p = 10;
float x = 1.25f;
double z = 5.5;
~~~

Pour chacune des variables `r1` à `r5`, indiquez :
- combien de conversions implicites sont mises en œuvre et lesquelles
- ce qu'elle vaut et quel est son type

Rappel Les promotions numériques : `bool → int`, `char → int` et `short → int`
**NB** Noter la réponse sous forme: int r10 = 73;

Subexo: 
~~~cpp
auto r1 = n + c + p;
~~~
Solution: 
~~~cpp
long r1 = 82; 
~~~
Explanation:
r1 = n + c + p
 
2 conversions implicites : c est tout d'abord converti en int, 
avant d'être ajouté à n. Le résultat (72), de type int, est 
ensuite converti en long, avant d'être ajouté à p. Au final, 
on obtient la valeur 82 de type long.

Subexo:
~~~cpp
auto r2 = 2 * x + c;
~~~
Solution: 
~~~cpp
float r2 = 67.5;
~~~
Explanation:
r2 = 2*x + c
 
3 conversions implicites : c (de type char) est tout d'abord 
converti en int (promotion numérique), ce qui donne 65. On 
évalue ensuite 2 * x en convertissant 2 (de type int) en float, 
ce qui donne 2.5 de type float. Pour effectuer l'addition, on
convertit la valeur entière 65 en float, avant de l'ajouter au 
résultat précédent (2.5).


Subexo:
~~~cpp
auto r3 = (char) n + c;
~~~
Solution: 
~~~cpp
int r3 = 72;
~~~
Explanation:
r3 = (char)n + c
 
2 conversions implicites : n est converti explicitement en char (cast)
c et (char)n sont tous les deux convertis implicitement en int 
(promotion numérique) avant d'etre additionnés.

Subexo:
~~~cpp
auto r4 = (float) z + n / 2;
~~~
Solution: 
~~~cpp
float r4 = 8.5;
~~~
Explanation:
r4 = (float) z + n / 2
 
1 conversion implicite : z est tout d'abord converti en float
(cast), ce qui donne 5.5. La division entière n / 2 est ensuite 
effectuée; on obtient la valeur 3. Cette valeur (3) est ensuite 
convertie en float, avant d'être ajoutée à 5.5. 

Subexo:
~~~cpp
auto r5 a + b;
~~~
Solution: 
~~~cpp
unsigned int r5 = numeric_limits<unsigned>::max(); // probablement 4'294'967'295
~~~
Explanation:
r5 = a + b;
 
1 conversion implicite (de type ajustement de type) de int en unsigned int. 
