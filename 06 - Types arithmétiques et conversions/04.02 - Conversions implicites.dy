skill Types arithmétiques et conversions
exo Conversions implicites 

Soient les déclarations et modificiations du flux ci-dessous 

~~~cpp 
signed char sc = -1;
signed int s = -1;

unsigned char uc = 1;
unsigned int u = 1;
double d = 1;

cout << setprecision(10) << boolalpha;
~~~

Notes
- `pow(2,8)`  vaut `256`
- `pow(2,16)` vaut `65536`
- `pow(2,32)` vaut `4294967296`

TODO: est-ce que la justification doit aller dans un open exo ?

Qu'affichent les lignes suivantes ? Justifiez votre réponse
- en ré-écrivant l'expression en rendant explicites toutes les conversions implicites
- en ajoutant toutes les parenthèses qui traduisent l'ordre implicite des opérateurs

---
subexo
~~~cpp
cout << s * d + u;
~~~
sol 0
exp équivalent à `((double(-1) * 1.) + double(1u))`

subexo 
~~~cpp
cout << s * u + d;
~~~
sol 4294967296
exp équivalent à `(double(unsigned(-1) * 1u) + 1.)`

subexo 
~~~cpp
cout << d * u + s;
~~~
sol 0
exp équivalent à `((1. * double(1u)) + double(-1))`

subexo 
~~~cpp
cout << sc * uc + d;
~~~
sol 0
exp équivalent à `(double(int(-1) * int(1)) + 1.)`

subexo 
~~~cpp
cout << sc * uc + s;
~~~
sol -2
exp équivalent à `(((int(-1) * int(1u)) + -1)`

subexo 
~~~cpp
cout << sc * uc - u;
~~~
sol 4294967294
exp équivalent à `(unsigned(int(-1) * int(1u)) - 1u)`

TODO. sur les 5 true/false, est-ce que ce n'est pas 0/1 plutôt ? comment avoir ça au mieux ?
subexo 
~~~cpp
cout << (s < u);
~~~
sol false
exp équivalent à `(unsigned(-1) < 1u)` avec `unsigned(-1)` qui vaut `4294967295`

subexo 
~~~cpp
cout << (s < d);
~~~
sol true
exp équivalent à `(double(-1) < 1.)`

subexo 
~~~cpp
cout << (-u < d);
~~~
sol false
exp équivalent à `(double(-1u) < -1)` avec `-1u` qui vaut `4294967295`

subexo 
~~~cpp
cout << (-uc < d);
~~~
sol true
exp équivalent à `(double(-int(1)) < 1.)`

subexo 
~~~cpp
cout << (-d < u);
~~~
sol true
exp équivalent à `(-1. < double(1u))`
